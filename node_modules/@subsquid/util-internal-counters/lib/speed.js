"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Speed = void 0;
const assert_1 = __importDefault(require("assert"));
class Speed {
    constructor(options) {
        this.window = [{ value: 0, time: 0n, duration: 0n }];
        this.tail = 1;
        this.value = 0;
        this.duration = 0n;
        let windowSize = options?.windowSize ?? 50;
        let windowGranularitySeconds = options?.windowGranularitySeconds ?? 0;
        (0, assert_1.default)(windowSize > 0);
        (0, assert_1.default)(windowGranularitySeconds >= 0);
        this.size = windowSize + 1;
        this.granularity = BigInt(windowGranularitySeconds) * 1000000000n;
    }
    start(time) {
        this.m = time ?? process.hrtime.bigint();
    }
    stop(val, time) {
        (0, assert_1.default)(this.m != null, 'mark should be set');
        let beg = this.m;
        this.m = undefined;
        let end = time ?? process.hrtime.bigint();
        if (end <= beg)
            return 0n;
        this.push(val, beg, end);
        return end - beg;
    }
    push(val, beg, end) {
        this.duration += end - beg;
        this.value += val;
        let last = this.window[(this.size + this.tail - 1) % this.size];
        if (this.window.length > 1 && last.time + this.granularity >= end) {
            last.value = this.value;
            last.duration = this.duration;
        }
        else {
            this.window[this.tail] = { value: this.value, duration: this.duration, time: end };
            this.tail = (this.tail + 1) % this.size;
        }
    }
    speed() {
        if (this.window.length < 2)
            return 0;
        let beg = this.window.length < this.size ? this.window[0] : this.window[this.tail];
        let end = this.window[(this.size + this.tail - 1) % this.size];
        let duration = end.duration - beg.duration;
        let inc = end.value - beg.value;
        return inc * 1000000000 / Number(duration);
    }
    time() {
        let speed = this.speed();
        return speed == 0 ? 0 : 1 / speed;
    }
}
exports.Speed = Speed;
//# sourceMappingURL=speed.js.map