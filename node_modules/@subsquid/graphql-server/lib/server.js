"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Server = void 0;
const utils_keyvadapter_1 = require("@apollo/utils.keyvadapter");
const utils_keyvaluecache_1 = require("@apollo/utils.keyvaluecache");
const schema_1 = require("@graphql-tools/schema");
const db_1 = require("@subsquid/openreader/lib/db");
const schema_2 = require("@subsquid/openreader/lib/opencrud/schema");
const server_1 = require("@subsquid/openreader/lib/server");
const tools_1 = require("@subsquid/openreader/lib/tools");
const limit_1 = require("@subsquid/openreader/lib/util/limit");
const util_internal_1 = require("@subsquid/util-internal");
const apollo_server_core_1 = require("apollo-server-core");
const apollo_server_plugin_response_cache_1 = __importDefault(require("apollo-server-plugin-response-cache"));
const assert_1 = __importDefault(require("assert"));
const graphql_1 = require("graphql");
const keyv_1 = __importDefault(require("keyv"));
const path = __importStar(require("path"));
const pg_1 = require("pg");
const process = __importStar(require("process"));
const check_1 = require("./check");
const typeorm_1 = require("./typeorm");
class Server {
    constructor(options = {}) {
        this.options = options;
        this.disposals = [];
        this.dir = path.resolve(options.dir || process.cwd());
    }
    start() {
        return (0, server_1.addServerCleanup)(this.disposals, this.bootstrap(), this.options.log);
    }
    async bootstrap() {
        let schema = await this.schema();
        let context = await this.context();
        let plugins = [];
        if (this.options.dumbCache) {
            plugins.push((0, apollo_server_core_1.ApolloServerPluginCacheControl)({ defaultMaxAge: this.options.dumbCache.maxAgeMs / 1000 }), (0, apollo_server_plugin_response_cache_1.default)());
        }
        let requestCheck = this.customCheck();
        if (requestCheck) {
            plugins.push((0, check_1.createCheckPlugin)(requestCheck, this.model()));
        }
        return (0, server_1.runApollo)({
            port: this.port(),
            disposals: this.disposals,
            schema,
            context,
            plugins,
            log: this.options.log,
            subscriptions: this.options.subscriptions,
            graphiqlConsole: true,
            maxRequestSizeBytes: this.options.maxRequestSizeBytes,
            maxRootFields: this.options.maxRootFields,
            cache: this.cache()
        });
    }
    async schema() {
        let schemas = [
            new schema_2.SchemaBuilder({ model: this.model(), subscriptions: this.options.subscriptions }).build()
        ];
        if (this.options.squidStatus !== false) {
            schemas.push(this.squidStatusSchema());
        }
        let customResolvers = await this.customResolvers();
        if (customResolvers) {
            schemas.push(customResolvers);
        }
        return (0, schema_1.mergeSchemas)({ schemas });
    }
    squidStatusSchema() {
        let statusQuery = {
            sql: `SELECT height FROM squid_processor.status WHERE id = 0`,
            params: [],
            map(rows) {
                (0, assert_1.default)(rows.length == 1);
                let height = parseInt(rows[0][0], 10);
                return { height };
            }
        };
        return new graphql_1.GraphQLSchema({
            query: new graphql_1.GraphQLObjectType({
                name: 'Query',
                fields: {
                    squidStatus: {
                        type: new graphql_1.GraphQLObjectType({
                            name: 'SquidStatus',
                            fields: {
                                height: {
                                    type: graphql_1.GraphQLInt,
                                    description: 'The height of the processed part of the chain'
                                }
                            }
                        }),
                        resolve(source, args, context) {
                            return context.openreader.executeQuery(statusQuery);
                        }
                    }
                }
            })
        });
    }
    async customResolvers() {
        let loc = this.module('lib/server-extension/resolvers');
        if (loc == null)
            return undefined;
        let { loadCustomResolvers } = await Promise.resolve().then(() => __importStar(require('./resolvers')));
        return loadCustomResolvers(loc);
    }
    customCheck() {
        let loc = this.module('lib/server-extension/check');
        if (loc == null)
            return undefined;
        let mod = require(loc);
        if (typeof mod.requestCheck != 'function') {
            throw new Error(`${loc} should export requestCheck() function`);
        }
        return mod.requestCheck;
    }
    module(name) {
        let loc = this.path(name);
        try {
            return require.resolve(loc);
        }
        catch (e) {
            return undefined;
        }
    }
    async context() {
        let dialect = this.dialect();
        let createOpenreader;
        if (await this.customResolvers()) {
            let con = await this.createTypeormConnection({ sqlStatementTimeout: this.options.sqlStatementTimeout });
            this.disposals.push(() => con.destroy());
            createOpenreader = () => {
                return new typeorm_1.TypeormOpenreaderContext(dialect, con, con, this.options.subscriptionPollInterval);
            };
        }
        else {
            let pool = await this.createPgPool({ sqlStatementTimeout: this.options.sqlStatementTimeout });
            this.disposals.push(() => pool.end());
            createOpenreader = () => {
                return new db_1.PoolOpenreaderContext(dialect, pool, pool, this.options.subscriptionPollInterval);
            };
        }
        return () => {
            let openreader = createOpenreader();
            if (this.options.maxResponseNodes) {
                openreader.responseSizeLimit = new limit_1.ResponseSizeLimit(this.options.maxResponseNodes);
                openreader.subscriptionResponseSizeLimit = new limit_1.ResponseSizeLimit(this.options.maxResponseNodes);
            }
            if (this.options.subscriptionMaxResponseNodes) {
                openreader.subscriptionResponseSizeLimit = new limit_1.ResponseSizeLimit(this.options.subscriptionMaxResponseNodes);
            }
            return { openreader };
        };
    }
    async createTypeormConnection(options) {
        let { createOrmConfig } = await Promise.resolve().then(() => __importStar(require('@subsquid/typeorm-config')));
        let { DataSource } = await Promise.resolve().then(() => __importStar(require('typeorm')));
        let cfg = {
            ...createOrmConfig({ projectDir: this.dir }),
            extra: {
                statement_timeout: options?.sqlStatementTimeout || undefined,
                max: this.connectionPoolSize(),
                min: this.connectionPoolSize()
            }
        };
        let con = new DataSource(cfg);
        await con.initialize();
        return con;
    }
    async createPgPool(options) {
        let { createConnectionOptions } = await Promise.resolve().then(() => __importStar(require('@subsquid/typeorm-config/lib/connectionOptions')));
        let params = createConnectionOptions();
        return new pg_1.Pool({
            host: params.host,
            port: params.port,
            database: params.database,
            user: params.username,
            password: params.password,
            statement_timeout: options?.sqlStatementTimeout || undefined,
            max: this.connectionPoolSize(),
            min: this.connectionPoolSize(),
            ssl: params.ssl
        });
    }
    connectionPoolSize() {
        return envNat('GQL_DB_CONNECTION_POOL_SIZE') || 5;
    }
    dialect() {
        let type = process.env.DB_TYPE;
        if (!type)
            return 'postgres';
        switch (type) {
            case 'cockroach':
                return 'cockroach';
            case 'postgres':
                return 'postgres';
            default:
                throw new Error(`Unknown database type passed via DB_TYPE environment variable: ${type}`);
        }
    }
    model() {
        let file = (0, tools_1.resolveGraphqlSchema)(this.dir);
        return (0, tools_1.loadModel)(file);
    }
    cache() {
        let log = this.options.log;
        let opts = this.options.dumbCache;
        switch (opts?.kind) {
            case 'redis':
                log?.warn(`enabling dumb redis cache (max-age: ${opts.maxAgeMs}ms)`);
                return new utils_keyvadapter_1.KeyvAdapter(new keyv_1.default(opts.url));
            case 'in-memory':
                log?.warn(`enabling dumb in-memory cache (size: ${opts.maxSizeMb}mb, ttl: ${opts.ttlMs}ms, max-age: ${opts.maxAgeMs}ms)`);
                return new utils_keyvaluecache_1.InMemoryLRUCache({
                    maxSize: opts.maxSizeMb * 1024 * 1024,
                    ttl: opts.ttlMs,
                });
        }
    }
    port() {
        return process.env.GQL_PORT || process.env.GRAPHQL_SERVER_PORT || 4000;
    }
    path(name) {
        return path.join(this.dir, name);
    }
}
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Server.prototype, "start", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Server.prototype, "schema", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", graphql_1.GraphQLSchema)
], Server.prototype, "squidStatusSchema", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Server.prototype, "customResolvers", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Object)
], Server.prototype, "customCheck", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Server.prototype, "context", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Number)
], Server.prototype, "connectionPoolSize", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Object)
], Server.prototype, "model", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Object)
], Server.prototype, "cache", null);
exports.Server = Server;
function envNat(name) {
    let env = process.env[name];
    if (!env)
        return undefined;
    let val = parseInt(env, 10);
    if (Number.isSafeInteger(val) && val >= 0)
        return val;
    throw new Error(`Invalid env variable ${name}: ${env}. Expected positive integer`);
}
//# sourceMappingURL=server.js.map